---
format: html
---

```{r}
#| label: setup
#| include: false
library(tidyverse)
```

## Input

```{r}
#| label: readin-input

read_lines(
"#.##..##.
..#.##.#.
##......#
##......#
..#.##.#.
..##..##.
#.#.##.#.

#...##..#
#....#..#
..##..###
#####.##.
#####.##.
..##..###
#....#..#

##.#.##
#.##...
.######
##....#
#.##.#.
.#.####
.#.####
#.##.#.
##....#
.######
#.##..#
##.#.##
..###..
..###..
##.#.##
#.##..#
.######

.####....#..##.##
..########..####.
.#..##..#..####..
#.#..#..###...###
..#...##.#..#.##.
###.#.##.###..##.
....###.#..####.#
....###.#..####.#
###.#.##.###..##.
..#...##.#..#.##.
#.#..#..###...###
.#..##..#..####..
..########..#.##.
.####....#..##.##
.####....#..##.##") -> input


```

Split input by blank empty lines
```{r}
input <- read_lines("input/13")
# from https://stackoverflow.com/a/50345309/1395352
split_vec <- function(vec, sep = 0) {
  is.sep <- vec == sep
  split(vec[!is.sep], cumsum(is.sep)[!is.sep])
}

splitted_input <- split_vec(input, sep = "")
```


## Part 1

Binarized the input

```{r}
conv2matrix <- function(grid) {
  grid |> 
    str_replace_all(c("\\." = "0", "#" = "1")) |> 
    tibble(x = _) |> 
    adventdrob::grid_matrix(var = x)
}


```


```{r}
map_int(splitted_input, \(x) {
  x <- conv2matrix(x)
  mc <- find_mirror_cols(x)
  mc <- ifelse(nrow(mc) > 0, max(mc$x), 0)
  mr <- find_mirror_rows(x)
  mr <- ifelse(nrow(mr) > 0, max(mr$x), 0)
  #message("mc", mc, " mr: ", mr)
  mc + (100 * mr)
}) -> tmp # |> reduce(`+`)
```

3521 too low


```{r}

x = splitted_input[[2]] |> conv2matrix()

is_mirrored <- function(mat, i, margin) {
  margin <- match.arg(margin, c("rows", "cols"))
  message("i ", i, " end ", (i * 2):(i + 1))
  if (margin == "rows") {
    all(mat[seq_len(i), ] == mat[(i * 2):(i + 1), ])
  } else {
    all(mat[, seq_len(i)] == mat[, (i * 2):(i + 1)])
  }
}

             # column left side 
mircols <- c(map_lgl(seq_len(floor(ncol(x) / 2)), \(i) is_mirrored(x, i, "cols")),
             # column right side, flip the matrix
             map_lgl(seq_len(floor(ncol(x) / 2)), \(i) is_mirrored(x[, ncol(x):1], i, "cols")) |> 
               rev())
             # rows up side 
mirrows <- c(map_lgl(seq_len(floor(nrow(x) / 2)), \(i) is_mirrored(x, i, "rows")),
             # rows bottom side, flip the matrix
             map_lgl(seq_len(floor(nrow(x) / 2)), \(i) is_mirrored(x[, nrow(x):1], i, "rows")) |> 
               rev())
message("mirror rows: ", mirrows, " cols: ", mircols)


```


Old crap:

```{r}

find_mirror_cols <- function(mat) {
  # pairs of cols that are identical
  expand_grid(x = seq_len(ncol(mat)), y = seq_len(ncol(mat))) |> 
    filter(x < y) |> 
    mutate(diff_cols = map2_lgl(x, y, \(x, y) all((mat[, x] - mat[, y]) == 0))) |> 
    filter(diff_cols) -> diffs 
  if (nrow(diffs) == 0) return(diffs)
  diffs |> 
    mutate(diffy = lag(y, default = max(y) + 1L) - y,
           diffx = lag(x, default = min(x) - 1L) - x) |> 
    # mirror must be contiguous
    filter((diffy + diffx) == 0 & (max(x) - min(y) == -1)) -> contiguous
  #message("contiguous: ", print(contiguous), " span: ", max(contiguous$y) - min(contiguous$x), " (over ", ncol(mat), ")")
  # should span the whole matrix -1
  if (nrow(contiguous) == 0 |  (max(contiguous$y) - min(contiguous$x)) < ncol(mat) - 2) return(tibble())
  contiguous |>  
    # valid if at least one of the column is one of border
    filter((min(x) == 1 | max(y) == ncol(mat)))
  # if we have cols, return min(y) otherwise empty test the rows
}


find_mirror_rows <- function(mat) {
  # pairs of rows that are identical
  expand_grid(x = seq_len(nrow(mat)), y = seq_len(nrow(mat))) |> 
    filter(x < y) |> 
    mutate(diff_rows = map2_lgl(x, y, \(x, y) all((mat[x, ] - mat[y, ]) == 0))) |> 
    filter(diff_rows) -> diffs 
  if (nrow(diffs) == 0) return(diffs)
  diffs |>  
    mutate(diffy = lag(y, default = max(y) + 1L) - y,
           diffx = lag(x, default = min(x) - 1L) - x) |> 
    # mirror must be contiguous
    filter((diffy + diffx) == 0 & (max(x) - min(y) == -1)) -> contiguous
  #message("contiguous: ", print(contiguous), " span: ", max(contiguous$y) - min(contiguous$x), " (over ", nrow(mat), ")")
  if (nrow(contiguous) == 0 | (max(contiguous$y) - min(contiguous$x)) < nrow(mat) - 2) return(tibble())
  contiguous |> 
    # valid if at least one of the column is one of border
    filter((min(x) == 1 | max(y) == nrow(mat)))
}
```

